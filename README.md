## JSON-driven forms

This project experiments with describing complex forms as JSON documents that power both the UI and backend validation. The core pieces live under `src/lib`:

- `formSchema.ts` – a Zod schema that validates raw JSON input and normalises defaults.
- `formParser.ts` – helper utilities to parse JSON safely and construct backend validators from a `FormConfig`.

`sample-form.json` showcases a non-trivial admin creation form with:

- Static and dynamic select fields (remote pagination, debounced queries, caching hints).
- Rich validation metadata (required messages, regex, min/max constraints, cross-field `sameAs`).
- Layout hints, conditional visibility rules, and submit button copy.

### Parse a form definition

```ts
import { promises as fs } from "node:fs";
import { parseFormConfig, buildBackendValidator } from "@/lib/formParser";

async function bootstrap() {
  const raw = await fs.readFile("sample-form.json", "utf-8");

  const config = parseFormConfig(raw);
  const validator = buildBackendValidator(config);

  // Validate request payloads (e.g. inside an API route)
  const dto = validator.parse({
    email: "admin@example.com",
    password: "supersecret!!",
    confirmPassword: "supersecret!!",
    organizationId: "org_123",
    permissions: ["manage_users"],
    receiveUpdates: true,
  });

  console.log(dto);
}
```

The validator is a `z.ZodObject`, so you can integrate it directly with API routes, Next.js Server Actions, tRPC routers, or any backend runtime where type-safe parsing matters.

### Build a form UI from JSON (shadcn-styled)

1. **Describe your form** – create a JSON document or plain object that matches `FormConfigInput`. See `src/forms/signInForm.ts` for a complete example.
2. **Validate and export** – call `parseFormConfig(yourJson)` and export the returned `FormConfig`. This guarantees the UI builder and backend parser read the same contract.
3. **Render with `FormBuilder`** – import `FormBuilder` in a client or server component and pass the validated config. The builder wires the config to shadcn-style inputs (`input`, `select`, `textarea`, `checkbox`, `toggle`, etc.), applies layout hints, and mounts a `react-hook-form` instance with a Zod resolver generated by `buildBackendValidator`.
4. **Handle submit** – by default the builder posts to `config.endpoint`, showing success/error messages from `config.submit`. You can also subscribe to the optional `onSubmitSuccess` / `onSubmitError` callbacks to run custom logic.

Example (`app/page.tsx`):

```tsx
import { FormBuilder } from "@/components/FormBuilder";
import { signInFormConfig } from "@/forms/signInForm";

export default function Page() {
  return (
    <main className="flex min-h-screen items-center justify-center bg-background p-6">
      <div className="w-full max-w-md space-y-6 rounded-xl border border-border bg-card p-6 shadow-sm">
        <FormBuilder config={signInFormConfig} />
      </div>
    </main>
  );
}
```

The builder automatically maps each `FormField` type to a matching shadcn-inspired control, enforces field visibility rules, hydrate default values, and fetches remote select options when a `dataSource` is defined.

### Adding new form fields

Update `src/types/form.types.ts` to describe new field capabilities, then extend `formSchema.ts` and `formParser.ts` so runtime validation stays aligned with TypeScript types. Regenerate or tweak your JSON definitions afterwards.

---

## Development flow

- Install dependencies: `npm install`
- Run the Next.js dev server: `npm run dev`
- Type-check the project: `npx tsc --noEmit`

The UI lives under `src/app`. Editing `app/page.tsx` while the dev server is running hot-reloads changes in the browser.
